# _*_coding:utf-8 _*_
# @Time    : 2022/5/4 10:45
# @Author  : Guo 
# @File    : 1823. 找出游戏的获胜者.py
# @Desc    :

"""
共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。
确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，
从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。

游戏遵循如下规则：
从第 1 名小伙伴所在位置 开始 。
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者
"""
from collections import deque


class Solution(object):
    def findTheWinner(self, n: int, k: int) -> int:
        """
        每次先算出当前列表长度，然后 k 取余，把相应位置pop掉，然后将之前的元素添加到后面
        然后循环
        直到列表长度为1
        """
        q = deque(range(1, n + 1))
        while len(q) > 1:
            for _ in range(k - 1):
                q.append(q.popleft())
            q.popleft()
        return q[0]

    def findTheWinner_v2(self, n, k): # 约瑟夫环 问题
        """
        解决约瑟夫环问题，我们采用倒推，我们倒推出：最后剩下的这个数字，在最开始的数组中的位置。

        剩下最后一个数字（简称“它”）的时候，总个数为 1，它的位置 pos = 0。  下一轮的数组的第一个数字是上一轮的数组第m+1个数字，下标为m。然后对上一轮数组长度n取模即(0+m)%n
        那么它在上一轮也是安全的，总个数为 2，它的位置 pos = (0 + m) % 2；
        那么它在上上轮也是安全的，总个数为 3，它的位置 pos = ((0 + m) % 2 + m) % 3
        那么它在上上上轮也是安全的，总个数为 4，它的位置 pos = (((0 + m) % 2 + m) % 3) % 4；
...
        那么它在游戏开始的第一轮也是安全的，总个数为 nn，它的位置 pospos 就是最后的结果。
        即如果从下向上反推的时候：假如它前一轮的索引为 pospos，那么当前轮次的位置就是 (pos + m) %当前轮次的人数。
        """
        pos = 0
        for i in range(2, n + 1):
            pos = (pos + k) % i
        return pos + 1
